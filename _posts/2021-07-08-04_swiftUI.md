---
layout: post
title: SwiftUI Lecture7-8 ì •ë¦¬
tags: [swiftUI]
---

ì´ë²ˆ ê°•ì˜ì—ì„œëŠ” Animationì— ëŒ€í•´ì„œ ê³µë¶€ë¥¼ ì§„í–‰í–ˆë‹¤. ì‹¤ì œ ì•±ì„ ì´ìš©í•˜ë‹¤ë³´ë©´ ì¹´ë“œê°€ ì´ë™í•œë‹¤ë˜ì§€ ì¹´ë“œì˜ ê·¸ë¦¼ì´ íšŒì „í•œë‹¤ë˜ì§€ í•˜ëŠ” ê²½ìš°ê°€ ìˆë‹¤. ì´ëŠ” ëª¨ë‘ Animation íš¨ê³¼ë¥¼ ì‚¬ìš©í•´ì„œ ì§„í–‰í•˜ëŠ” ê²ƒìœ¼ë¡œ iOSì—ì„œëŠ” ìì²´ì ìœ¼ë¡œ animation ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

## 1. ViewModifier

Animationì— ëŒ€í•´ í•™ìŠµí•˜ê¸° ì „ì— ViewModifierì— ëŒ€í•´ ë¨¼ì € ì•Œì•„ë³´ê³  ë„˜ì–´ê°€ì. .font, .backGroundColor ì™€ ê°™ì´ Viewì˜ ì†ì„±ì„ ì¡°ì •í•´ì£¼ëŠ” í•¨ìˆ˜ë“¤ì„ ê¸°ì–µí•  ê²ƒì´ë‹¤. ViewModifierëŠ” ì´ëŸ¬í•œ í–‰ìœ„ë¥¼ í•˜ê²Œ í•´ì£¼ëŠ” í”„ë¡œí† ì½œì˜ ì¼ì¢…ìœ¼ë¡œ Viewì—ê²Œ íŠ¹ì •í•œ í–‰ìœ„ë¥¼ í•´ì£¼ê³ ì í•  ë•Œ ì‚¬ìš©í•œë‹¤. 

```swift
struct Cardify: ViewModifier {
		var isFaceUp: Bool
  	func body(content: Content) -> some View {
  			if isFaceUp {
      			content.font(.largeTitle)
    		} else {
      			content.font(.title)
    		}
  	}
}
Text("ğŸ‘»").modifier(Cardify(isFaceUp: true))
```

View structë¥¼ ë§Œë“œëŠ” ê²ƒê³¼ ë¹„ìŠ·í•˜ê²Œ ì‘ì„±í•˜ë©´ ë˜ë©° var bodyê°€ ì•„ë‹Œ func bodyë¥¼ ë§Œë“œëŠ” ê²ƒì„ ìœ ì˜í•˜ì. ì´ ë•Œ contentë¼ëŠ” ë³€ìˆ˜ê°€ ì‚¬ìš©ë˜ëŠ”ë° ì´ëŠ” inputìœ¼ë¡œ ë°›ëŠ” viewë¥¼ ì˜ë¯¸í•˜ë©° ê·¸ viewê°€ ì–´ë–¤ ê²ƒì´ë˜ì§€ body í•¨ìˆ˜ ë‚´ë¶€ì˜ í–‰ìœ„ë¥¼ ì ìš©ì‹œì¼œì¤€ë‹¤. ViewModifierì—ì„œëŠ” isFaceUpê³¼ ê°™ì€ argumentê°€ ë§¤ìš° ì¤‘ìš”í•œë° ì™œëƒí•˜ë©´ ì´ ê°’ì´ ë³€í• ë•Œë§ˆë‹¤ ì• ë‹ˆë©”ì´ì…˜ì„ ì‘ë™ì‹œí‚¬ ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

ë§Œì•½ .modifier() ì™€ ê°™ì€ í˜•íƒœë¡œ ì‚¬ìš©í•˜ê³  ì‹¶ì§€ ì•Šê³  ë‹¤ë¥¸ fontì™€ ê°™ì€ modifier ì²˜ëŸ¼ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ë¥¼ í•´ì£¼ë©´ ëœë‹¤.

```swift
extension View {
    func cardify(isFaceUp: Bool) -> some View {
        return self.modifier(Cardify(isFaceUp: isFaceUp))
    }
}
Text("ğŸ‘»").cardify(isFaceUp: true)
```

ì°¸ê³ ë¡œ ëª¨ë“  ViewModifierê°€ animatable í•˜ì§€ëŠ” ì•Šë‹¤. ì˜ˆë¥¼ë“¤ì–´ fontëŠ” animatableí•˜ì§€ ì•Šë‹¤. ViewModifierê°€ animatable í•˜ë‹¤ëŠ” ê²ƒì„ ë‚˜íƒ€ë‚´ê³  ì‹¶ì„ ë•ŒëŠ” var animatableData: Type(Dont care) ë¥¼ ì‚¬ìš©í•´ì¤˜ì•¼í•œë‹¤. ì´ê²ƒì€ í•´ë‹¹ ë³€ìˆ˜ê°€ ë³€í•  ë•Œ ì„ í˜•ì ìœ¼ë¡œ ë³€í•˜ë„ë¡ í•˜ê² ë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤. animatableDataëŠ” VectoArithmetic í•´ì•¼í•˜ë©° AnimatablePairë¥¼ ê°€ì§ˆìˆ˜ë„ìˆë‹¤. ì´ë¥¼ ì ìš©í•´ì„œ Cardify ViewModifier Structë¥¼ ë‹¤ì‹œí•œë²ˆ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. ë§Œì•½ ë³€í™”í•˜ëŠ” animatableDataê°€ í•œê°œë¼ë©´ **AnimatableModifier**ë¡œ ì„ ì–¸í•´ì£¼ê³  ë‘ê°œë¼ë©´ **AnimatablePair<Type, Type>**ë¡œ ì„ ì–¸í•´ì£¼ì.

```swift
struct Cardify: AnimatableModifier {
    init(isFaceUp: Bool) {
        rotation = isFaceUp ? 0 : 180
    }
    
    var animatableData: Double {
        get { rotation }
        set { rotation = newValue }
    }
    
    var rotation: Double // in degrees
    func body(content: Content) -> some View {
        ZStack {
            let shape = RoundedRectangle(cornerRadius: DrawingConstants.cornerRadius)
            if rotation < 90 {
                shape.fill().foregroundColor(.white)
                shape.strokeBorder(lineWidth: DrawingConstants.lineWidth)
            } else {
                shape.fill()
            }
            content
                .opacity(rotation < 90 ? 1 : 0)
        }
        .rotation3DEffect(Angle.degrees(rotation), axis: (0, 1, 0))
    }
}

```



## 2. Animation

ì ì´ì œ ì• ë‹ˆë©”ì´ì…˜ì— ëŒ€í•´ì„œ ì•Œì•„ë³´ì. ì• ë‹ˆë©”ì´ì…˜ì€ ViewModifierë‚˜ Shapeë¥¼ ì´ìš©í•´ì„œ ì ìš©ì´ ê°€ëŠ¥í•˜ê³  ë¬´ì–¸ê°€ ë³€ìˆ˜ê°€ ë³€í•˜ê±°ë‚˜ Viewì˜ ë“±ì¥ê³¼ ì†Œë©¸ì— ëŒ€í•´ì„œ ì• ë‹ˆë©”ì´ì…˜ì´ ë™ì‘í•œë‹¤. ì´ ë•Œ Viewì— ëŒ€í•œ ì• ë‹ˆë©”ì´ì…˜ì€ í•´ë‹¹ Viewê°€ UIì— ë“¤ì–´ê°„ í›„ì—ë§Œ ì¼ì–´ë‚  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ëª…ì‹¬í•˜ì. íŠ¹ì • Viewì˜ ë“±ì¥ê³¼ ì†Œë©¸ì— ëŒ€í•œ ì• ë‹ˆë©”ì´ì…˜ì„ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´ í•´ë‹¹ Viewë¥¼ ê°ì‹¸ëŠ” Containerê°€ ì´ë¯¸ UIì— ì¡´ì¬í•´ ìˆì–´ì•¼ í•œë‹¤.

ì• ë‹ˆë©”ì´ì…˜ì€ í¬ê²Œ 3ê°€ì§€ì˜ ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ êµ¬ë¶„ëœë‹¤. Implicitly, explicitly, transitionì´ ê·¸ì— í•´ë‹¹í•œë‹¤. 

1. Implicitly

   ì¼ëª… automatical animationìœ¼ë¡œë„ ë¶ˆë¦¬ëŠ” ì´ ë…€ì„ì€ ì„¤ì •ì„ í•´ì£¼ë©´ í•´ë‹¹ viewì— ëŒ€í•´ ì–´ë–¤ argumentê°€ ë³€í•˜ë©´ ìë™ì ìœ¼ë¡œ ì• ë‹ˆë©”ì´ì…˜ì´ ì ìš©ë˜ëŠ” í˜•íƒœì´ë‹¤. .animation(Animation)ì˜ í˜•íƒœë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

   ```swift
   Text("ğŸ‘»")
       .opacity(scary ? 1 : 0)
       .rotationEffect(Angle.degrees(upsideDown ? 180 : 0))
       .animation(Animation.eraseInOut)
   ```

   ìœ„ì™€ ê°™ì´ ì„¤ì •ì„ í•´ì£¼ë©´ scary ë³€ìˆ˜ì™€ upsideDown ë³€ìˆ˜ê°€ ë³€í• ë•Œë§ˆë‹¤ íˆ¬ëª…ë„ê°€ ë³€í•œë‹¤ë˜ì§€ ë¹™ê¸€ë¹™ê¸€ ë„ëŠ” ì• ë‹ˆë©”ì´ì…˜ì´ ìë™ìœ¼ë¡œ ì„¤ì •ë˜ëŠ” í˜•íƒœì´ë‹¤. ì´ ë•Œ .animationì€ ë³¸ì¸ ì´ì „ì— ì„ ì–¸ëœ ViewModifierì— ëŒ€í•´ì„œë§Œ í•´ë‹¹ animation ì†ì„±ì„ ì ìš©ì‹œí‚¨ë‹¤. 

   Animation structëŠ” ì—¬ëŸ¬ê°€ì§€ animationì˜ ì†ì„±ì„ ì„¤ì •í•  ìˆ˜ ìˆë‹¤. duration, delay, repeatë“±ì´ ì´ì— í•´ë‹¹í•œë‹¤. ë˜í•œ animation curve ì†ì„±ì„ ì„¤ì •í•  ìˆ˜ ìˆëŠ”ë° ì´ëŠ” ì• ë‹ˆë©”ì´ì…˜ì´ ë™ì‘í•˜ëŠ” ì†ë„ í…œí¬ë¥¼ ì¡°ì ˆí•˜ëŠ” ì—­í• ì„ í•œë‹¤. .linear ëŠ” ê· ì¼í•˜ê²Œ, .eraseInOutì€ ì²˜ìŒê³¼ ëì„ ëŠë¦¬ê²Œ, .springì€ ëë‚ ë•Œ ì‚´ì§ ìŠ¤í”„ë§ì²˜ëŸ¼ í”ë“¤ë¦¬ë„ë¡ í•˜ëŠ” ì—­í• ì„ í•œë‹¤. 

2. Explicitly

   ImplicitlyëŠ” Viewì— ì„ ì–¸ëœ ëª¨ë“  argumentê°€ ë³€í• ë•Œë§ˆë‹¤ ìë™ìœ¼ë¡œ ì ìš©ì´ ë˜ì—ˆë‹¤ë©´ ExplicitlyëŠ” ë‚´ê°€ ì›í•˜ëŠ” ë™ì‘ì„ ìˆ˜í–‰í•  ë•Œ ë³€í•˜ëŠ” argumentì—ê²Œë§Œ animationì„ ì£¼ê² ë‹¤ëŠ” ê²ƒì´ë‹¤. ì‚¬ìš©ë²•ìœ¼ë¡œëŠ” withAnimation(Animation) { } ì˜ í˜•íƒœë¥¼ ì‚¬ìš©í•˜ë©° ëŒ€ê´„í˜¸ ë‚´ë¶€ì— ì›í•˜ëŠ” í•¨ìˆ˜ë“¤ì„ ì •ì˜í•´ì£¼ë©´ ëœë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ Animation structì—ëŠ” ì—¬ëŸ¬ê°€ì§€ ì†ì„±ì„ ì„¤ì •í•  ìˆ˜ ìˆë‹¤.

   ```swift
   withAnimation(.linear(duration: 2)) {
       //do somthing that will cause ViewModifier/Shape arguments to change somewhere
   }
   ```

3. Transition

   Viewê°€ ìƒì„±ë˜ê³  ì‚­ì œë ë•Œ ìˆ˜í–‰í•  ì• ë‹ˆë©”ì´ì…˜ì— ëŒ€í•´ ì„¤ì •í•´ ì¤„ ìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ë“¤ì–´ ë“±ì¥í• ë•ŒëŠ” ì ì  íˆ¬ëª…ë„ê°€ ë³€í•´ì„œ ë“±ì¥í•˜ê³  ì‚­ì œë  ë•ŒëŠ” í¬ê¸°ê°€ ì ì  ì¤„ì–´ë“¤ì–´ ì‚­ì œë˜ê²Œ í•œë‹¤ë˜ì§€ ì„¤ì •ì„ í•´ì¤„ ìˆ˜ ìˆë‹¤. ì´ ë•Œ Transitionì€ CTAAOS (Containers That Are Already On-Screen) ì•ˆì— ìˆëŠ” Viewì— ëŒ€í•´ì„œë§Œ ë™ì‘í•œë‹¤. í˜•íƒœë¡œëŠ” .transition(AnyTransition) ì˜ í˜•íƒœë¡œ AnyTransition struct ë‚´ë¶€ì— pre-canned transition ëª©ë¡ë“¤ì´ ì •ì˜ë˜ì–´ ìˆë‹¤.

   ```swift
   CardView(card: $0)
   		.matchedGeometryEffect(id: $0.id, in: dealingNamespace)
   		.transition(.asymmetric(insertion: .identity, removal: .scale))
   		.zIndex(zIndex(of: $0)) // zIndex(Double) ì†ì„±ì„ ì„¤ì •í•´ì£¼ì–´ ê²¹ì³¤ì„ ë–„ ì–´ë–¤ Viewê°€ ìœ„ë¡œê°ˆì§€ ì •í•´ì¤Œ
   ```

   ìœ ì˜í•  ì ìœ¼ë¡œëŠ” transitionì€ ë‹¨ìˆœíˆ ë“±ì¥ê³¼ ì‚­ì œí• ë•Œ ë°œìƒí•  ì• ë‹ˆë©”ì´ì…˜ì„ ì •ì˜í•´ì£¼ì—ˆì„ ë¿ ì‹¤ì œë¡œ ì• ë‹ˆë©”ì´ì…˜ì´ ì‘ë™í•˜ì§€ëŠ” ì•ŠëŠ”ë‹¤. ë”°ë¼ì„œ Implicitly Animationì´ë‚˜ Explicitly Animationì„ ì´ìš©í•´ì„œ ë°œë™ì‹œì¼œì•¼í•œë‹¤.

   Transitionì€ ì™¸ë¶€ Containerì— ì ìš©í•˜ë©´ Container ì „ì²´ê°€ ìƒì„±ë˜ê³  ì‚­ì œë  ë•Œ ì ìš©ì´ ë˜ëŠ” í˜•íƒœì´ë‹¤. ë‚´ë¶€ì˜ Viewë“¤ì—ê²Œ ê·¸ ì •ë³´ë¥¼ ë„˜ê²¨ì£¼ì§€ ì•ŠëŠ”ë‹¤. ì•½ê°„ Paddingê³¼ ë¹„ìŠ·í•˜ë‹¤ê³  ìƒê°í•˜ë©´ ëœë‹¤. í•˜ì§€ë§Œ Implicitly Animationì€ ì™¸ë¶€ Containerì— ì„ ì–¸ì„ í•˜ë©´ ë‚´ë¶€ì˜ ëª¨ë“  Viewë“¤ì—ê²Œ ê°ê° ì ìš©ì´ ëœë‹¤. ë§ˆì¹˜ backGroundColorë¥¼ ì™¸ë¶€ ì»¨í…Œì´ë„ˆì— ì„ ì–¸í•˜ë©´ ë‚´ë¶€ ëª¨ë“  Viewë“¤ì—ê²Œ ì ìš©ë˜ëŠ” ê²ƒì²˜ëŸ¼ ë§ì´ë‹¤.

## 3. matchedGeometyEffect

ë§Œì•½ íŠ¹ì • containerì—ì„œ ë‹¤ë¥¸ containerë¡œ Viewë¥¼ ì˜®ê²¨ê°€ê³  ì‹¶ë‹¤ë©´ ì–´ë–»ê²Œ í•´ì•¼í• ê¹Œ? ì•„ì‰½ê²Œë„ ì• ë‹ˆë©”ì´ì…˜ ìì²´ì ìœ¼ë¡œëŠ” í•´ë‹¹ ê¸°ëŠ¥ì„ ìˆ˜í–‰í•  ìˆ˜ ì—†ë‹¤. ì´ë¥¼ ìœ„í•´ ì¡´ì¬í•˜ëŠ” ê¸°ëŠ¥ì´ ë°”ë¡œ .matchedGeometryEffect(id: ID, in: Namespace)ì™€ ê°™ì€ í˜•íƒœë¡œ ì‚¬ìš©í•œë‹¤. ì‚¬ìš©í•˜ê³  ì‹¶ì€ ë‘ containerì— ëŒ€í•´ì„œ ëª¨ë‘ ì„ ì–¸ì„ í•´ì£¼ë©´ í•˜ë‚˜ì˜ containerì—ì„œ ë‹¤ë¥¸ containerë¡œ ì´ë™í•˜ëŠ” ê²ƒê³¼ ê°™ì€ animation íš¨ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤.

ì—¬ê¸°ì„œ idëŠ” ìš°ë¦¬ê°€ viewì— ì‚¬ìš©í•˜ëŠ” idì— í•´ë‹¹í•˜ê³  namespaceëŠ” ë™ì¼í•œ idë¥¼ ê°–ëŠ”ë‹¤í•´ë„ ì—¬ëŸ¬ ì»¨í…Œì´ë„ˆì— ì¡´ì¬í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì–´ë–¤ ì»¨í…Œì´ë„ˆì—ì„œ ì–´ë–¤ ì»¨í…Œì´ë„ˆë¡œ ê°ˆ ê²ƒì¸ì§€ë¥¼ ë§¤ì¹­ì‹œì¼œì£¼ê¸° ìœ„í•´ ì‚¬ìš©í•œë‹¤. `@Namespace private var dealingNamespace` ì™€ ê°™ì´ ìƒìœ„ view structì— ì„ ì–¸í•´ì£¼ê³  ì‚¬ìš©í•˜ë©´ ëœë‹¤.

```swift
    var gameBody: some View {
        AspectVGrid(items: game.cards, aspectRatio: CardConstants.aspectRatio) { card in
            if isUndealt(card) || (card.isMatched && !card.isFaceUp) {
                Color.clear
            } else {
                CardView(card: card)
                    .matchedGeometryEffect(id: card.id, in: dealingNamespace)
                    .padding(4)
                    .transition(.asymmetric(insertion: .identity, removal: .scale))
                    .zIndex(zIndex(of: card))
                    .onTapGesture {
                        withAnimation {
                            game.choose(card)
                        }
                    }
            }
        }
        .foregroundColor(CardConstants.color)
    }
    
    var deckBody: some View {
        ZStack {
            ForEach(game.cards.filter(isUndealt)) {
                CardView(card: $0)
                    .matchedGeometryEffect(id: $0.id, in: dealingNamespace)
                    .transition(.asymmetric(insertion: .identity, removal: .scale))
                    .zIndex(zIndex(of: $0))
            }
        }
        .frame(width: CardConstants.undealtWidth, height: CardConstants.undealtHeight)
        .foregroundColor(CardConstants.color)
        .onTapGesture {
            for card in game.cards {
                withAnimation(dealAnimation(for: card)) {
                    deal(card)
                }
            }
        }
    }
```

ìœ„ì˜ ì½”ë“œë¥¼ ë³´ë©´ deckBodyì—ì„œ ì‚¬ë¼ì§€ê³  gameBodyë¡œ Cardê°€ ìƒì„±ë  ë•Œ ë§ˆì¹˜ ì¹´ë“œê°€ ì´ë™í•˜ëŠ” ê²ƒì²˜ëŸ¼ íš¨ê³¼ë¥¼ ì¤„ ìˆ˜ ìˆë‹¤.
