---
layout: post
title: SwiftUI Lecture3-4 ì •ë¦¬
tags: [swiftUI]
---

## MVVM(Model View ViewModel)

Modelê³¼ View, ViewModelë¡œ ë‚˜ëˆ„ëŠ” ë°©ì‹ì„ MVVM ëª¨ë¸ì´ë¼ê³  ë¶€ë¥¸ë‹¤. Dataë¥¼ ì €ì¥í•˜ê³  ê·¸ì— ê´€ë ¨í•œ Logicì„ í¬í•¨í•˜ê³  ìˆëŠ” Model, Dataë¥¼ ë°”íƒ•ìœ¼ë¡œ UIë¥¼ ë§Œë“¤ì–´ì£¼ëŠ” UI Architectureì¸ View, ë§ˆì§€ë§‰ìœ¼ë¡œ ë‘˜ ì‚¬ì´ì—ì„œ ì§•ê²€ë‹¤ë¦¬ì²˜ëŸ¼ ì—°ê²°ì„ í•´ì£¼ëŠ” ViewModelë¡œ ë‚˜ë‰˜ì–´ì§€ëŠ” êµ¬ì¡°ì´ë‹¤. í•˜ë‚˜í•˜ë‚˜ ë‚˜ëˆ ì„œ ì‚´í´ë³´ì.

## 1. Model

UI Independentí•œ í˜•íƒœë¡œ Dataì™€ ê·¸ì™€ ê´€ë ¨ëœ Logicìœ¼ë¡œ êµ¬ì„±ë˜ì–´ìˆë‹¤. ìš°ë¦¬ì˜ ì½”ë“œë¥¼ MVVMëª¨ë¸ë¡œ ì ìš©ì‹œí‚¤ê¸° ìœ„í•´ ë§Œë“  Modelì˜ ëª¨ìŠµì€ ë‹¤ìŒê³¼ ê°™ë‹¤. ë†€ëê²Œë„ UI Independentí•˜ê¸° ë•Œë¬¸ì— `import SwiftUI`ê°€ ì—†ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. 

ë©”ëª¨ë¦¬ ê²Œì„ì„ ì‹¤í–‰ì‹œí‚¤ë©´ í•´ë‹¹ ê²Œì„ì˜ ì¹´ë“œ Set (**Data**) ì„ ì €ì¥í•´ì¤˜ì•¼í•˜ê³  í•´ë‹¹ ì¹´ë“œë¥¼ í´ë¦­í–ˆì„ ë•Œ ì¹´ë“œì˜ ì†ì„±ì´ ë³€í•˜ëŠ” ê²ƒì„ ì²˜ë¦¬í•´ì£¼ëŠ” ì—°ì‚° í•¨ìˆ˜ (**Logic**)ê°€ í¬í•¨ë˜ì–´ìˆë‹¤. ì‹¤ì œë¡œ chooseí•¨ìˆ˜ë¥¼ ë³´ë©´ íŠ¹ì • ì¹´ë“œë¥¼ ëˆŒë €ì„ ë•Œ ì²˜ë¦¬í•  ì—°ì‚°ì´ í•¨ìˆ˜í˜•íƒœë¡œ êµ¬í˜„ë˜ì–´ìˆë‹¤. ë†€ëê²Œë„ UIì™€ëŠ” ì „í˜€ ë¬´ê´€í•˜ê²Œ ê°€ì§€ê³  ìˆëŠ” card setë§Œìœ¼ë¡œ ë™ì‘í•œë‹¤. ìš°ë¦¬ëŠ” ì–´ë–¤ ì¹´ë“œê°€ ì„ íƒë˜ì—ˆëŠ”ì§€ ê·¸ ì •ë³´ë§Œ Viewë¡œë¶€í„° ë°›ìœ¼ë©´ ë˜ëŠ” í˜•íƒœì´ë‹¤.

```swift
import Foundation

struct MemoryGame<CardContent> where CardContent: Equatable {
    private(set) var cards: Array<Card>
    private var indexOfTheOneAndOnlyFaceUpCard: Int?
    
    mutating func choose(_ card: Card) {
        if let chosenIndex = cards.firstIndex(where: { $0.id == card.id }),
           !cards[chosenIndex].isFaceUp,
           !cards[chosenIndex].isMatched {
            if let potentialMatchIndex = indexOfTheOneAndOnlyFaceUpCard {
                if cards[potentialMatchIndex].content == cards[chosenIndex].content {
                    cards[chosenIndex].isMatched = true
                    cards[potentialMatchIndex].isMatched = true
                }
                indexOfTheOneAndOnlyFaceUpCard = nil
            } else {
                for index in cards.indices {
                    cards[index].isFaceUp = false
                }
                indexOfTheOneAndOnlyFaceUpCard = chosenIndex
            }
            cards[chosenIndex].isFaceUp.toggle()
        }
    }
    
    init(numberOfPairsOfCards: Int, createCardContent: (Int) -> CardContent) {
        cards = Array<Card>()
        // add numberOfPairsOfCards x 2 to array
        for pairIndex in 0..<numberOfPairsOfCards {
            let content = createCardContent(pairIndex)
            cards.append(Card(content: content, id: pairIndex*2))
            cards.append(Card(content: content, id: pairIndex*2+1))
        }
    }
    
    struct Card: Identifiable {
        var isFaceUp: Bool = false
        var isMatched: Bool = false
        var content: CardContent
        var id: Int
    }
}
```

êµ¬í˜„ìì²´ëŠ” ê°„ë‹¨í•˜ë‹ˆ ì¡°ê¸ˆë§Œ ì½ì–´ë³´ë©´ ì•Œ ìˆ˜ ìˆë‹¤. Modelì—ì„œ ì¤‘ìš”í•œ í¬ì¸íŠ¸ê°€ ëª‡ê°€ì§€ ìˆëŠ”ë° ì´ë¥¼ ì•Œì•„ë³´ê³  ë„˜ì–´ê°€ë ¤ê³  í•œë‹¤. 

1. Generic Type

   ìŠ¤ìœ„í”„íŠ¸ì—ì„œëŠ” ë‚˜ì¤‘ì— íƒ€ì…ì„ ë§¤ì¹­ì‹œì¼œì£¼ëŠ” generic type ì„ ì–¸ì´ ì¡´ì¬í•œë‹¤. `<CardContent>`ê°€ ì´ì— í•´ë‹¹í•˜ëŠ”ë° ìš°ë¦¬ê°€ ì¹´ë“œì˜ ì´ë¯¸ì§€ë¡œ ì‚¬ìš©í•˜ëŠ” ê°’ì´ í˜„ì¬ëŠ” emoji Stringì´ì§€ë§Œ ì„¤ì •ì— ë”°ë¼ JPEGê°€ ë  ìˆ˜ë„ ìˆê³  ë‹¤ì–‘í•  ê²ƒì´ë‹¤. ì´ëŠ” ViewModelì— ë§¡ê¸°ê³  Modelì—ì„œëŠ” Logicêµ¬í˜„ì— ì¢€ ë” ì‹ ê²½ì„ ì¨ì£¼ëŠ” ëª¨ìŠµì´ë‹¤. 

2. Identifiable

   `struct Card: Identifiable`ë¡œ í‘œí˜„ì´ ë˜ì–´ìˆëŠ” ê²ƒì„ Card êµ¬ì¡°ì²´ì—ì„œ í™•ì¸ì´ ê°€ëŠ¥í•˜ë‹¤. ìš°ë¦¬ê°€ Viewì—ì„œ ê°ê°ì˜ ì¹´ë“œë¥¼ í•˜ë‚˜ì˜ Viewë¡œ í‘œí˜„í•˜ê¸° ìœ„í•´ì„œëŠ” idê°€ ì¡´ì¬í•´ì•¼ í–ˆë‹¤ëŠ” ê²ƒì„ ê¸°ì–µí•  ê²ƒì´ë‹¤. ë”°ë¼ì„œ Card êµ¬ì¡°ì²´ëŠ” Identifiableí•˜ë‹¤ê³  ì„ ì–¸í•´ì£¼ê³  êµ¬ì¡°ì²´ ë‚´ë¶€ì— ì´ë¥¼ êµ¬ë¶„ì§€ì–´ì£¼ëŠ” idë¥¼ ì„¤ì •í•´ì£¼ëŠ” í˜•íƒœì´ë‹¤. idëŠ” ê¼­ Intê°€ ì•„ë‹ˆì—¬ë„ Hashableí•˜ë‹¤ë©´ ë‹¤ë¥¸ í˜•íƒœë¥¼ ì‚¬ìš©í•´ë„ ë¬´ë°©í•˜ë‹¤. 

3. Read Only

   `private(set) var cards: Array<Card>` ë¡œ í‘œí˜„ëœ ë¶€ë¶„ì„ ë³¼ ìˆ˜ ìˆë‹¤. ì´ ê²ƒì´ ìš°ë¦¬ì˜ Dataì¸ Card Setì„ ì €ì¥í•´ì£¼ëŠ” ë°°ì—´ì´ë‹¤. ê°ê°ì˜ Cardë“¤ì€ ë’¤ì§‘í˜€ìˆëŠ”ì§€, ë§¤ì¹˜ê°€ ì™„ë£Œë˜ì—ˆëŠ”ì§€, ê·¸ë¦¼ ì •ë³´ëŠ” ë¬´ì—‡ì¸ì§€, idëŠ” ë¬´ì—‡ì¸ì§€ë¥¼ ì €ì¥í•´ì£¼ê³  ìˆë‹¤. í›„ì— Viewì—ì„œëŠ” ì¹´ë“œë“¤ì˜ í•´ë‹¹ ì •ë³´ë¥¼ ViewModelì„ í†µí•´ ì½ì–´ì™€ì„œ ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ UIë¥¼ ê·¸ë¦°ë‹¤. 

   ê·¸ëŸ°ë° í•´ë‹¹ ë°°ì—´ì„ privateìœ¼ë¡œ ì„ ì–¸ì„ í•œë‹¤ë©´ ë‹¤ë¥¸ ê³³ì—ì„œ ì½ì–´ì˜¤ëŠ” ê²ƒì´ ë¶ˆí¸í•´ì§ˆ ê²ƒì´ë‹¤. ê·¸ë ‡ë‹¤ê³  publicìœ¼ë¡œ ì„ ì–¸ì„ í•˜ë©´ viewì—ì„œ ê°’ì„ ë³€ê²½í•´ë²„ë¦¬ëŠ” ìœ„í—˜ì´ ì¡´ì¬í•˜ê¸° ë•Œë¬¸ì— read only í˜•íƒœì¸ private(set) ì„ ì‚¬ìš©í•œë‹¤.



## 2. ViewModel

Modelê³¼ Viewì˜ ì§•ê²€ë‹¤ë¦¬ ì—­í• ì„ í•˜ëŠ” ViewModelì´ë‹¤. Interpreter, GateKeeperì˜ ì„±ì§ˆì„ ì§€ë‹ˆê³  ìˆë‹¤. Viewì—ì„œ UIë¥¼ ê·¸ë¦¬ë ¤ê³  í•œë‹¤ë©´ ë‹¤ìŒì˜ ë°©ì‹ì„ ë”°ë¥¸ë‹¤. 

1. Modelì˜ Card ì •ë³´ë¥¼ ì•Œê¸° ìœ„í•´ ViewModelì˜ cards ë³€ìˆ˜ë¥¼ í˜¸ì¶œ
2. ViewModelì€ Modelì˜ cards ë³€ìˆ˜ë¥¼ í˜¸ì¶œ
3. ì–»ì–´ë‚¸ Modelì˜ cardsë¥¼ í†µí•´ UIë¥¼ ê·¸ë¦¼



ë§ˆì°¬ê°€ì§€ë¡œ Viewì—ì„œ íŠ¹ì • ì¹´ë“œë¥¼ ì„ íƒí•˜ëŠ” ë“± ë³€í™”ê°€ ìƒê¸´ë‹¤ë©´ ë‹¤ìŒì˜ ë°©ì‹ì„ ë”°ë¥¸ë‹¤. 

1. ViewModelì˜ Logic í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
2. ViewModelì€ Modelì˜ Logic í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
3. Modelì—ì„œ Logicì„ í†µí•´ Data ì •ë³´ë¥¼ ë³€ê²½
4. ë³€ê²½ëœ ì •ë³´ê°€ ì¡´ì¬í•˜ë¯€ë¡œ Modelì´ ë‹¤ì‹œ UIë¥¼ ê·¸ë¦¬ë¼ê³  ViewModelì—ê²Œ ìš”ì²­
5. ViewModelì€ Viewì—ê²Œ UIë¥¼ ë‹¤ì‹œ ê·¸ë¦¬ë¼ê³  ìš”ì²­
6. ìœ„ì˜ UI ê·¸ë¦¬ëŠ” ë°©ì‹ì„ ë‹¤ì‹œ ë°˜ë³µí•˜ì—¬ ìƒˆë¡œìš´ UI ì‘ì„±



ì´ë ‡ë“¯ Modelê³¼ ViewëŠ” ì§ì ‘ ì†Œí†µí•  ìˆ˜ ì—†ê³  ViewModelì´ ì¤‘ê°„ì—ì„œ ì—°ê²°ì‹œì¼œì£¼ëŠ” í˜•íƒœë¡œ ë˜ì–´ìˆë‹¤ëŠ” ê²ƒì´ë‹¤. Modelì´ ì •ì˜ê°€ ë˜ì–´ìˆë‹¤ë©´ í•´ë‹¹ Modelì„ ì‚¬ìš©í•˜ë©´ ë˜ì§€ë§Œ ìš°ë¦¬ì˜ ê²½ìš°ëŠ” Modelì„ ì§ì ‘ ìƒì„±í•´ì£¼ëŠ” í˜•íƒœë¡œ ë˜ì–´ìˆë‹¤. ìœ ì˜í•  ê²ƒì€ í•´ë‹¹ ëª¨ë¸ì€ privateìœ¼ë¡œ ì„ ì–¸í•´ì„œ Viewì—ì„œ ì§ì ‘ Modelì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¼ì´ ì—†ë„ë¡ í•´ì•¼í•œë‹¤ëŠ” ê²ƒì´ë‹¤. 

```swift
import SwiftUI

class EmojiMemoryGame: ObservableObject {
    static let emojis = ["ğŸš–", "ğŸ›µ", "ğŸš†", "ğŸš", "ğŸ›º", "ğŸ›«", "ğŸ–", "ğŸš”", "ğŸ›¸", "ğŸš", "ğŸ", "ğŸ›³", "ğŸš", "ğŸš›", "ğŸšš"]
    
    static func createMemoryGame() -> MemoryGame<String> {
        MemoryGame<String>(numberOfPairsOfCards: 3) { pairIndex in
            emojis[pairIndex]
        }
    }
    
    @Published private var model: MemoryGame<String> = createMemoryGame()
    
    var cards: Array<MemoryGame<String>.Card> {
        model.cards
    }
    
    // MARK: - Intent(s)
    
    func choose(_ card: MemoryGame<String>.Card) {
        //objectWillChange.send()
        model.choose(card)
    }
}
```

ê·¸ëŸ°ë° Modelì˜ Dataê°€ ë³€ê²½ë˜ì—ˆì„ ë•Œ ë‹¤ì‹œ UIë¥¼ ê·¸ë¦¬ë„ë¡ ìš”ì²­í•˜ê¸° ìœ„í•´ì„œëŠ” ëª‡ê°€ì§€ ìˆ˜ì •ì´ í•„ìš”í•˜ë‹¤. ë°”ë¡œ Observe ì†ì„±ì„ ì„¤ì •í•´ì£¼ëŠ” ê²ƒì¸ë° ì´ëŠ” í•´ë‹¹ Modelì„ ë³´ê³ ìˆë‹¤ê°€ ë³€í™”ê°€ ìƒê¸´ë‹¤ë©´ ìë™ìœ¼ë¡œ Viewì—ê²Œ ë‹¤ì‹œ UIë¥¼ ê·¸ë¦¬ë¼ê³  ìš”ì²­í•´ì£¼ëŠ” ì—­í• ì„ í•œë‹¤. ì´ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” 2ê°€ì§€ ë°©ì‹ì´ ì¡´ì¬í•œë‹¤. 

ë¨¼ì € `class EmojiMemoryGame: ObservableObject`ì™€ ê°™ì´ ObservableObjectë¡œ ViewModelì„ ì„ ì–¸í•´ì£¼ì–´ì•¼í•œë‹¤. ê·¸ë¦¬ê³  ë‚˜ì¤‘ì— View Struct ì•ˆì—ì„œ ViewModelì„ ì„ ì–¸í•´ì¤„ ë•Œ `@ObservedObject var viewModel: EmojiMemoryGame` í˜•íƒœë¡œ @ObservedObjectì„ì„ ëª…ì‹œí•´ì¤˜ì•¼í•œë‹¤. ì´ëŠ” í•´ë‹¹ ViewModelì„ ì§€ì†ì ìœ¼ë¡œ ê´€ì°°í•´ì„œ ìš”ì²­ì´ ë“¤ì–´ì˜¤ë©´ UI Updateë¥¼ í•˜ê² ë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤. 

ë‘ë²ˆì§¸ë¡œëŠ” Modelì—ì„œ ìš”ì²­ì´ ë“¤ì–´ì™”ì„ ë•Œ ì´ë¥¼ ViewModelì´ ê°ì‹œí•´ì•¼í•œë‹¤ëŠ” ê²ƒì¸ë° Model ìì²´ë¥¼ `@Published`ë¡œ ì„ ì–¸í•´ì„œ ë³€í™”ê°€ ìƒê¸¸ ë•Œë§ˆë‹¤ UIë¥¼ ìƒˆë¡œ ê·¸ë¦¬ë„ë¡ í•  ìˆ˜ë„ ìˆê³  choose functionì˜ `objectWillChange.send()`ë¥¼ í†µí•´ì„œ í•„ìš”í•  ë•Œ Updateë¥¼ í•˜ë„ë¡ ì§ì ‘ ëª…ì‹œí•´ì¤„ ìˆ˜ë„ ìˆë‹¤.

## 3. View

ë§ˆì§€ë§‰ íŒŒíŠ¸ì¸ Viewì´ë‹¤. Viewì—ëŠ” ë˜ë„ë¡ @Stateì„ ì–¸ê³¼ ê°™ì´ ë°ì´í„°ë¥¼ ì§ì ‘ ì¡°ì‘í•˜ëŠ” ì¼ì´ ì—†ë„ë¡ êµ¬í˜„í•´ì£¼ëŠ” ê²ƒì´ ì¢‹ë‹¤. ëª¨ë“  ì •ë³´ëŠ” Modelì— ì €ì¥ë˜ì–´ ìˆëŠ” ì •ë³´ë¥¼ ViewModelì„ í†µí•´ í˜¸ì¶œí•˜ëŠ” í˜•ì‹ìœ¼ë¡œ êµ¬í˜„í•œë‹¤. ìœ„ì—ì„œ ë´¤ë“¯ì´ `@ObservedObject`ë¡œ ViewModelì„ ì„ ì–¸í•´ì£¼ëŠ” ê²ƒì„ ìŠì§€ë§ì. 

```swift
import SwiftUI

struct ContentView: View {
    @ObservedObject var viewModel: EmojiMemoryGame
    var body: some View {
        ScrollView {
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 65))]) {
                ForEach(viewModel.cards){ card in
                    CardView(card: card)
                        .aspectRatio(2/3, contentMode: .fit)
                        .onTapGesture {
                            viewModel.choose(card)
                        }
                }
            }
        }
        .foregroundColor(.red)
        .padding(.horizontal)
    }
}



struct CardView: View {
    let card: MemoryGame<String>.Card
    var body: some View {
        ZStack {
            let shape = RoundedRectangle(cornerRadius: 20.0)
            if card.isFaceUp {
                shape.fill().foregroundColor(.white)
                shape.strokeBorder(lineWidth: 3.0)
                Text(card.content).font(.largeTitle)
            } else if card.isMatched {
                shape.opacity(0)
            } else {
                shape.fill()
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        let game = EmojiMemoryGame()
        ContentView(viewModel: game)
            .preferredColorScheme(.dark)
        ContentView(viewModel: game)
            .preferredColorScheme(.light)
    }
}
```

